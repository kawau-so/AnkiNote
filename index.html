<!DOCTYPE html>
<html lang="ja">
<head>
  <meta name="robots" content="noindex">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="UTF-8" />
  <link rel="manifest" href="./site.webmanifest">
  <title>暗記ツール</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      text-align: center;
      background: #f0f0f0;
      height: 100vh;
      overflow: auto;
    }
    #canvas-container {
      position: relative;
      display: inline-block;
      border: 1px solid #ccc;
      margin-top: 10px;
      overflow: auto;
      touch-action: manipulation;
      transform-origin: top left;
      transition: transform 0.2s ease;
    }
    #main-image {
      display: block;
      max-width: none;
      height: auto;
    }
    .mask {
      position: absolute;
      background-color: transparent;
      pointer-events: auto;
      cursor: pointer;
      border: 2px solid red;
      box-sizing: border-box;
    }
    .visible {
      background-color: black;
    }
    button, select {
      margin: 10px;
    }
    #zoom-controls {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>暗記ツール</h1>
  <input type="file" id="imageUploader" accept="image/*"><br>
  <button id="editModeBtn">編集モード</button>
  <button id="memoryModeBtn">暗記モード</button>
  <select id="textSelector" style="display:none;"></select>
  <div id="zoom-controls">
    ズーム: <input type="range" id="zoomSlider" min="0.5" max="3" step="0.1" value="1">
  </div>
  <div id="canvas-container"></div>

  <script>
    const imageUploader = document.getElementById('imageUploader');
    const canvasContainer = document.getElementById('canvas-container');
    const editModeBtn = document.getElementById('editModeBtn');
    const memoryModeBtn = document.getElementById('memoryModeBtn');
    const textSelector = document.getElementById('textSelector');
    const zoomSlider = document.getElementById('zoomSlider');
    let mode = 'edit';
    let ocrResults = [];
    let zoomLevel = 1;

    const image = new Image();
    image.id = 'main-image';

    let firstTap = null;

    imageUploader.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        image.src = event.target.result;
        image.onload = () => {
          canvasContainer.innerHTML = '';
          canvasContainer.appendChild(image);
          recognizeText(image);
        };
      };
      reader.readAsDataURL(file);
    });

    editModeBtn.addEventListener('click', () => {
      mode = 'edit';
      firstTap = null;
    });

    memoryModeBtn.addEventListener('click', () => {
      mode = 'memory';
      firstTap = null;
    });

    zoomSlider.addEventListener('input', () => {
      zoomLevel = parseFloat(zoomSlider.value);
      canvasContainer.style.transform = `scale(${zoomLevel})`;
    });

    canvasContainer.addEventListener('click', (e) => {
      if (!image.src || mode !== 'edit') return;
      const rect = canvasContainer.getBoundingClientRect();
      const x = (e.clientX - rect.left + canvasContainer.scrollLeft) / zoomLevel;
      const y = (e.clientY - rect.top + canvasContainer.scrollTop) / zoomLevel;

      if (!firstTap) {
        firstTap = { x, y };
        return;
      }

      const x0 = Math.min(firstTap.x, x);
      const y0 = Math.min(firstTap.y, y);
      const x1 = Math.max(firstTap.x, x);
      const y1 = Math.max(firstTap.y, y);

      const mask = document.createElement('div');
      mask.className = 'mask';
      mask.style.left = `${x0}px`;
      mask.style.top = `${y0}px`;
      mask.style.width = `${x1 - x0}px`;
      mask.style.height = `${y1 - y0}px`;
      canvasContainer.appendChild(mask);

      firstTap = null;
    });

    canvasContainer.addEventListener('click', (e) => {
      if (mode === 'memory') {
        const target = e.target;
        if (target.classList.contains('mask')) {
          target.classList.toggle('visible');
        }
      }
    });

    function recognizeText(imageElement) {
      textSelector.style.display = 'none';
      Tesseract.recognize(
        imageElement.src,
        'jpn',
        { logger: m => console.log(m) }
      ).then(result => {
        const words = result.data.words;
        ocrResults = words;
        textSelector.innerHTML = '<option disabled selected>文字を選んでください</option>';
        words.forEach((word, index) => {
          const option = document.createElement('option');
          option.value = index;
          option.textContent = word.text;
          textSelector.appendChild(option);
        });
        textSelector.style.display = 'inline';
      });
    }

    textSelector.addEventListener('change', () => {
      const selectedIndex = textSelector.value;
      const word = ocrResults[selectedIndex];
      if (!word) return;

      const { bbox } = word;
      const x0 = bbox.x0 || word.bbox.x;
      const y0 = bbox.y0 || word.bbox.y;
      const x1 = bbox.x1 || (x0 + word.bbox.w);
      const y1 = bbox.y1 || (y0 + word.bbox.h);

      const imgRect = image.getBoundingClientRect();
      const scaleX = image.naturalWidth / imgRect.width;
      const scaleY = image.naturalHeight / imgRect.height;

      const mask = document.createElement('div');
      mask.className = 'mask';
      mask.style.left = `${x0 / scaleX}px`;
      mask.style.top = `${y0 / scaleY}px`;
      mask.style.width = `${(x1 - x0) / scaleX}px`;
      mask.style.height = `${(y1 - y0) / scaleY}px`;
      canvasContainer.appendChild(mask);
    });
  </script>
</body>
</html>
